<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Admin â€” Chess Simul Scoreboard</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css?v=2">
  <style>
    body { overflow-y: auto; }
    .admin-container {
      max-width: 800px;
      margin: 0 auto;
      padding: 24px 20px 48px;
    }
    .admin-container h1 {
      font-size: 1.5rem;
      margin-bottom: 24px;
    }
    section {
      margin-bottom: 32px;
    }
    section h2 {
      font-size: 1.15rem;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--stroke-default);
    }
    .player-card {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      padding: 14px 16px;
      margin-bottom: 8px;
    }
    .player-card .player-name {
      flex: 1;
      font-weight: 500;
    }
    .player-card input[type="number"] {
      width: 80px;
      min-height: 40px;
      padding: 8px 10px;
    }
    .player-card select {
      width: 100px;
      min-height: 40px;
      padding: 8px 10px;
    }
    .player-card .btn {
      padding: 8px 16px;
      min-height: 40px;
      font-size: 0.875rem;
    }
    .empty-state {
      color: var(--text-muted);
      font-style: italic;
      padding: 12px 0;
    }
    .queue-item {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      padding: 10px 16px;
      margin-bottom: 6px;
    }
    .queue-item .queue-name {
      flex: 1;
      font-weight: 500;
    }
    .queue-item .queue-time {
      color: var(--text-caption);
      font-size: 0.8rem;
    }
    .queue-item .btn {
      padding: 8px 14px;
      min-height: 40px;
      font-size: 0.875rem;
    }
    .score-form {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: flex-end;
    }
    .score-form .field {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .score-form .field label {
      font-size: 0.8rem;
      font-weight: 600;
      color: var(--text-body);
    }
    .score-form input {
      min-height: 40px;
      padding: 8px 10px;
    }
    .score-form .btn {
      padding: 8px 20px;
      min-height: 40px;
      font-size: 0.875rem;
    }
    .score-item {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      padding: 10px 16px;
      margin-bottom: 6px;
    }
    .score-item .score-name {
      flex: 1;
      font-weight: 500;
    }
    .score-item .score-moves {
      color: var(--text-body);
      font-size: 0.875rem;
    }
    .score-item select {
      width: 100px;
      min-height: 36px;
      padding: 6px 8px;
      font-size: 0.8rem;
    }
    .score-item .btn {
      padding: 6px 12px;
      min-height: 36px;
      font-size: 0.8rem;
    }
    .reset-section {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    .reset-section .btn {
      padding: 10px 20px;
      font-size: 0.875rem;
    }
  </style>
</head>
<body>
  <div class="admin-container">
    <h1>Admin Panel</h1>

    <!-- Section A: Currently Playing -->
    <section>
      <h2>Currently Playing</h2>
      <div id="playing-list"></div>
    </section>

    <!-- Section B: Queue -->
    <section>
      <h2>Queue</h2>
      <div id="queue-list"></div>
    </section>

    <!-- Section C: Score Entry -->
    <section>
      <h2>Score Entry</h2>
      <div class="score-form">
        <div class="field">
          <label for="score-name">Player Name</label>
          <input type="text" id="score-name" placeholder="Name" style="width:200px;">
        </div>
        <div class="field">
          <label for="score-moves">Moves</label>
          <input type="number" id="score-moves" placeholder="#" min="0" max="999" style="width:90px;">
        </div>
        <div class="field">
          <label for="score-outcome">Outcome</label>
          <select id="score-outcome" style="width:100px; min-height:40px; padding:8px 10px;">
            <option value="lost">Lost</option>
            <option value="won">Won</option>
            <option value="drew">Drew</option>
          </select>
        </div>
        <button class="btn btn-primary" id="score-submit-btn">Add Score</button>
      </div>
    </section>

    <!-- Section D: Submitted Scores -->
    <section>
      <h2>Submitted Scores</h2>
      <div id="scores-list"></div>
    </section>

    <!-- Section E: Settings -->
    <section>
      <h2>Settings</h2>
      <div class="score-form">
        <div class="field">
          <label for="max-players">Simultaneous boards</label>
          <input type="number" id="max-players" min="1" max="12" value="3" style="width:80px;">
        </div>
        <button class="btn btn-primary" id="save-settings-btn">Save</button>
      </div>
      <p class="text-caption mt-8">Number of players that can play at once (1â€“12). Default: 3.</p>
    </section>

    <!-- Section F: Reset -->
    <section>
      <h2>Reset</h2>
      <div class="reset-section">
        <button class="btn btn-danger" id="reset-scores-btn">Reset Scoreboard</button>
        <button class="btn btn-danger" id="reset-all-btn">Reset Everything</button>
      </div>
    </section>
  </div>

  <script type="module">
    import { firebaseConfig } from './firebase-config.js';
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js";
    import { getDatabase, ref, set, push, onValue, update, remove, get }
      from "https://www.gstatic.com/firebasejs/10.14.1/firebase-database.js";

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // --- Max players setting ---
    let maxPlayers = 3;

    onValue(ref(db, 'settings/maxPlayers'), (snapshot) => {
      maxPlayers = snapshot.exists() ? snapshot.val() : 3;
      document.getElementById('max-players').value = maxPlayers;
    });

    document.getElementById('save-settings-btn').addEventListener('click', async () => {
      const val = parseInt(document.getElementById('max-players').value, 10);
      if (isNaN(val) || val < 1 || val > 12) {
        alert('Enter a number between 1 and 12.');
        return;
      }
      await set(ref(db, 'settings/maxPlayers'), val);
    });

    // --- Auto-assign helper: promote next queued player if fewer than maxPlayers playing ---
    async function autoAssign() {
      const snap = await get(ref(db, 'queue'));
      if (!snap.exists()) return;
      const all = Object.entries(snap.val());
      const playingCount = all.filter(([, v]) => v.status === 'playing').length;
      if (playingCount >= maxPlayers) return;

      const nextQueued = all
        .filter(([, v]) => v.status === 'queued')
        .sort((a, b) => a[1].queuedAt - b[1].queuedAt);

      if (nextQueued.length === 0) return;

      const [nextId] = nextQueued[0];
      await update(ref(db, 'queue/' + nextId), { status: 'playing' });
    }

    // --- Section A: Currently Playing ---
    const playingList = document.getElementById('playing-list');

    onValue(ref(db, 'queue'), (snapshot) => {
      playingList.innerHTML = '';
      const data = snapshot.val() || {};

      const playing = Object.entries(data)
        .filter(([, v]) => v.status === 'playing');

      // Always show maxPlayers slots
      for (let slot = 0; slot < maxPlayers; slot++) {
        if (slot < playing.length) {
          const [id, player] = playing[slot];
          renderPlayerSlot(slot + 1, id, player);
        } else {
          const card = document.createElement('div');
          card.className = 'card player-card';
          const label = document.createElement('span');
          label.style.fontWeight = '700';
          label.style.minWidth = '70px';
          label.textContent = 'Slot ' + (slot + 1);
          const empty = document.createElement('span');
          empty.className = 'player-name';
          empty.style.color = 'var(--text-muted)';
          empty.style.fontStyle = 'italic';
          empty.textContent = 'Open';
          card.appendChild(label);
          card.appendChild(empty);
          playingList.appendChild(card);
        }
      }

      // --- Also render queue list from same listener ---
      renderQueue(data);
    });

    function renderPlayerSlot(slotNum, id, player) {
      const card = document.createElement('div');
      card.className = 'card player-card';

      const label = document.createElement('span');
      label.style.fontWeight = '700';
      label.style.minWidth = '70px';
      label.textContent = 'Slot ' + slotNum;

      const name = document.createElement('span');
      name.className = 'player-name';
      name.textContent = player.name;

      const movesInput = document.createElement('input');
      movesInput.type = 'number';
      movesInput.min = '0';
      movesInput.max = '999';
      movesInput.placeholder = 'Moves';

      const outcomeSelect = document.createElement('select');
      ['lost', 'won', 'drew'].forEach(val => {
        const opt = document.createElement('option');
        opt.value = val;
        opt.textContent = val.charAt(0).toUpperCase() + val.slice(1);
        outcomeSelect.appendChild(opt);
      });

      const completeBtn = document.createElement('button');
      completeBtn.className = 'btn btn-primary';
      completeBtn.textContent = 'Complete';
      completeBtn.addEventListener('click', async () => {
        const moves = parseInt(movesInput.value, 10);
        if (isNaN(moves) || moves < 0) {
          alert('Enter a valid move count.');
          return;
        }
        const outcome = outcomeSelect.value;
        const bonus = outcome === 'won' ? 50 : outcome === 'drew' ? 25 : 0;
        completeBtn.disabled = true;
        try {
          const scoreRef = push(ref(db, 'scores'));
          await set(scoreRef, {
            name: player.name,
            moves: moves,
            outcome: outcome,
            rankingScore: moves + bonus,
            completedAt: Date.now()
          });
          await update(ref(db, 'queue/' + id), {
            status: 'completed',
            moves: moves
          });
          await autoAssign();
        } catch (err) {
          alert('Error: ' + err.message);
        }
        completeBtn.disabled = false;
      });

      const clearBtn = document.createElement('button');
      clearBtn.className = 'btn btn-secondary';
      clearBtn.textContent = 'Clear';
      clearBtn.addEventListener('click', async () => {
        clearBtn.disabled = true;
        try {
          await update(ref(db, 'queue/' + id), { status: 'completed' });
          await autoAssign();
        } catch (err) {
          alert('Error: ' + err.message);
        }
        clearBtn.disabled = false;
      });

      card.appendChild(label);
      card.appendChild(name);
      card.appendChild(movesInput);
      card.appendChild(outcomeSelect);
      card.appendChild(completeBtn);
      card.appendChild(clearBtn);
      playingList.appendChild(card);
    }

    // --- Section B: Queue ---
    const queueList = document.getElementById('queue-list');

    function renderQueue(data) {
      queueList.innerHTML = '';

      const queued = Object.entries(data)
        .filter(([, v]) => v.status === 'queued')
        .sort((a, b) => a[1].queuedAt - b[1].queuedAt);

      if (queued.length === 0) {
        const empty = document.createElement('p');
        empty.className = 'empty-state';
        empty.textContent = 'No players in queue.';
        queueList.appendChild(empty);
        return;
      }

      queued.forEach(([id, player]) => {
        const item = document.createElement('div');
        item.className = 'card queue-item';

        const nameSpan = document.createElement('span');
        nameSpan.className = 'queue-name';
        nameSpan.textContent = player.name;

        const timeSpan = document.createElement('span');
        timeSpan.className = 'queue-time';
        timeSpan.textContent = new Date(player.queuedAt).toLocaleTimeString();

        const removeBtn = document.createElement('button');
        removeBtn.className = 'btn btn-danger';
        removeBtn.textContent = 'Remove';
        removeBtn.addEventListener('click', async () => {
          if (!confirm('Remove ' + player.name + ' from the queue?')) return;
          await remove(ref(db, 'queue/' + id));
        });

        const assignBtn = document.createElement('button');
        assignBtn.className = 'btn btn-primary';
        assignBtn.textContent = 'Start Playing';
        assignBtn.addEventListener('click', async () => {
          assignBtn.disabled = true;
          try {
            await update(ref(db, 'queue/' + id), { status: 'playing' });
          } catch (err) {
            alert('Error: ' + err.message);
          }
          assignBtn.disabled = false;
        });

        item.appendChild(nameSpan);
        item.appendChild(timeSpan);
        item.appendChild(removeBtn);
        item.appendChild(assignBtn);
        queueList.appendChild(item);
      });
    }

    // --- Section C: Score Entry ---
    document.getElementById('score-submit-btn').addEventListener('click', async () => {
      const nameInput = document.getElementById('score-name');
      const movesInput = document.getElementById('score-moves');
      const outcomeSelect = document.getElementById('score-outcome');
      const name = nameInput.value.trim();
      const moves = parseInt(movesInput.value, 10);
      const outcome = outcomeSelect.value;

      if (!name) {
        alert('Enter a player name.');
        return;
      }
      if (isNaN(moves) || moves < 0) {
        alert('Enter a valid move count.');
        return;
      }

      const bonus = outcome === 'won' ? 50 : outcome === 'drew' ? 25 : 0;

      try {
        const scoreRef = push(ref(db, 'scores'));
        await set(scoreRef, {
          name: name,
          moves: moves,
          outcome: outcome,
          rankingScore: moves + bonus,
          completedAt: Date.now()
        });
        nameInput.value = '';
        movesInput.value = '';
        outcomeSelect.value = 'lost';
      } catch (err) {
        alert('Error adding score: ' + err.message);
      }
    });

    // --- Section D: Submitted Scores ---
    const scoresList = document.getElementById('scores-list');

    onValue(ref(db, 'scores'), (snapshot) => {
      scoresList.innerHTML = '';
      const data = snapshot.val() || {};
      const scores = Object.entries(data)
        .map(([id, s]) => ({ id, ...s }))
        .sort((a, b) => {
          const aRank = a.rankingScore != null ? a.rankingScore : a.moves;
          const bRank = b.rankingScore != null ? b.rankingScore : b.moves;
          if (bRank !== aRank) return bRank - aRank;
          return a.completedAt - b.completedAt;
        });

      if (scores.length === 0) {
        const empty = document.createElement('p');
        empty.className = 'empty-state';
        empty.textContent = 'No scores yet.';
        scoresList.appendChild(empty);
        return;
      }

      scores.forEach((score) => {
        const item = document.createElement('div');
        item.className = 'card score-item';

        const nameSpan = document.createElement('span');
        nameSpan.className = 'score-name';
        const icon = score.outcome === 'won' ? 'ðŸ‘‘ ' : score.outcome === 'drew' ? 'ðŸ¤ ' : '';
        nameSpan.textContent = icon + score.name;

        const movesSpan = document.createElement('span');
        movesSpan.className = 'score-moves';
        const bonus = score.outcome === 'won' ? ' (+50)' : score.outcome === 'drew' ? ' (+25)' : '';
        movesSpan.textContent = score.moves + ' moves' + bonus;

        const outcomeSelect = document.createElement('select');
        ['lost', 'won', 'drew'].forEach(val => {
          const opt = document.createElement('option');
          opt.value = val;
          opt.textContent = val.charAt(0).toUpperCase() + val.slice(1);
          if (val === (score.outcome || 'lost')) opt.selected = true;
          outcomeSelect.appendChild(opt);
        });

        const saveBtn = document.createElement('button');
        saveBtn.className = 'btn btn-primary';
        saveBtn.textContent = 'Save';
        saveBtn.addEventListener('click', async () => {
          const newOutcome = outcomeSelect.value;
          const newBonus = newOutcome === 'won' ? 50 : newOutcome === 'drew' ? 25 : 0;
          saveBtn.disabled = true;
          try {
            await update(ref(db, 'scores/' + score.id), {
              outcome: newOutcome,
              rankingScore: score.moves + newBonus
            });
          } catch (err) {
            alert('Error: ' + err.message);
          }
          saveBtn.disabled = false;
        });

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'btn btn-danger';
        deleteBtn.textContent = 'Delete';
        deleteBtn.addEventListener('click', async () => {
          if (!confirm('Delete score for ' + score.name + '?')) return;
          await remove(ref(db, 'scores/' + score.id));
        });

        item.appendChild(nameSpan);
        item.appendChild(movesSpan);
        item.appendChild(outcomeSelect);
        item.appendChild(saveBtn);
        item.appendChild(deleteBtn);
        scoresList.appendChild(item);
      });
    });

    // --- Section E: Reset ---
    document.getElementById('reset-scores-btn').addEventListener('click', async () => {
      if (!confirm('Are you sure? This will clear all scores. This cannot be undone.')) return;
      await remove(ref(db, 'scores'));
    });

    document.getElementById('reset-all-btn').addEventListener('click', async () => {
      if (!confirm('Are you sure? This will clear ALL scores and queue entries. This cannot be undone.')) return;
      await remove(ref(db, 'scores'));
      await remove(ref(db, 'queue'));
    });
  </script>
</body>
</html>
